#include "kem.hpp"
#include "lightsaber_kem.hpp"
#include "prng.hpp"
#include "sha3_256.hpp"
#include "test_utils.hpp"
#include <fstream>
#include <gtest/gtest.h>
#include <string>

// Ensure that Saber KEM algorithms are functioning correctly, by
//
// - generating a new keypair
// - encapsulating message, generating cipher text and 32 -bytes shared secret
// - decapsulating cipher text, generating 32 -bytes shared secret
// - asserting equality of shared secret obtained by both parties
template<const size_t L,
         const size_t EQ,
         const size_t EP,
         const size_t ET,
         const size_t MU,
         const size_t seedBytes,
         const size_t noiseBytes,
         const size_t keyBytes>
void
test_saber_kem()
{
  constexpr size_t pklen = saber_utils::kem_pklen<L, EP, seedBytes>();
  constexpr size_t sklen = saber_utils::kem_sklen<L, EQ, EP, seedBytes, keyBytes>();
  constexpr size_t ctlen = saber_utils::kem_ctlen<L, EP, ET>();
  constexpr size_t sslen = sha3_256::DIGEST_LEN;

  std::vector<uint8_t> seedA(seedBytes);
  std::vector<uint8_t> seedS(noiseBytes);
  std::vector<uint8_t> z(keyBytes);
  std::vector<uint8_t> m(keyBytes);
  std::vector<uint8_t> pkey(pklen);
  std::vector<uint8_t> skey(sklen);
  std::vector<uint8_t> ctxt(ctlen);
  std::vector<uint8_t> seskey_a(sslen);
  std::vector<uint8_t> seskey_b(sslen);

  auto _seedA = std::span<uint8_t, seedBytes>(seedA);
  auto _seedS = std::span<uint8_t, noiseBytes>(seedS);
  auto _z = std::span<uint8_t, keyBytes>(z);
  auto _m = std::span<uint8_t, keyBytes>(m);
  auto _pkey = std::span<uint8_t, pklen>(pkey);
  auto _skey = std::span<uint8_t, sklen>(skey);
  auto _ctxt = std::span<uint8_t, ctlen>(ctxt);
  auto _seskey_a = std::span<uint8_t, sslen>(seskey_a);
  auto _seskey_b = std::span<uint8_t, sslen>(seskey_b);

  prng::prng_t prng;

  prng.read(_seedA);
  prng.read(_seedS);
  prng.read(_z);
  prng.read(_m);

  saber_kem::keygen<L, EQ, EP, MU, seedBytes, noiseBytes, keyBytes>(
    _seedA, _seedS, _z, _pkey, _skey);
  saber_kem::encaps<L, EQ, EP, ET, MU, seedBytes, keyBytes>(
    _m, _pkey, _ctxt, _seskey_a);
  saber_kem::decaps<L, EQ, EP, ET, MU, seedBytes, keyBytes>(_ctxt, _skey, _seskey_b);

  EXPECT_EQ(seskey_a, seskey_b);
}

// Ensure functional correctness and conformance of LightSaber KEM scheme, using known
// answer test files, generated by following instructions @
// https://gist.github.com/itzmeanjan/e499eba2b8c42f150a795d9e1c3c5dea.
void
kat_lightsaber()
{
  using namespace std::literals;

  const std::string kat_file = "./kats/lightsaber.kat";
  std::fstream file(kat_file);

  while (true) {
    std::string seedA0;

    if (!std::getline(file, seedA0).eof()) {
      std::string seedS0;
      std::string z0;
      std::string pkey0;
      std::string skey0;
      std::string m0;
      std::string ctxt0;
      std::string ss0;

      std::getline(file, seedS0);
      std::getline(file, z0);
      std::getline(file, pkey0);
      std::getline(file, skey0);
      std::getline(file, m0);
      std::getline(file, ctxt0);
      std::getline(file, ss0);

      auto seedA1 = std::string_view(seedA0);
      auto seedS1 = std::string_view(seedS0);
      auto z1 = std::string_view(z0);
      auto pkey1 = std::string_view(pkey0);
      auto skey1 = std::string_view(skey0);
      auto m1 = std::string_view(m0);
      auto ctxt1 = std::string_view(ctxt0);
      auto ss1 = std::string_view(ss0);

      auto seedA2 = seedA1.substr(seedA1.find("="sv) + 2, seedA1.size());
      auto seedS2 = seedS1.substr(seedS1.find("="sv) + 2, seedS1.size());
      auto z2 = z1.substr(z1.find("="sv) + 2, z1.size());
      auto pkey2 = pkey1.substr(pkey1.find("="sv) + 2, pkey1.size());
      auto skey2 = skey1.substr(skey1.find("="sv) + 2, skey1.size());
      auto m2 = m1.substr(m1.find("="sv) + 2, m1.size());
      auto ctxt2 = ctxt1.substr(ctxt1.find("="sv) + 2, ctxt1.size());
      auto ss2 = ss1.substr(ss1.find("="sv) + 2, ss1.size());

      auto seedA = saber_test_utils::from_hex(seedA2);
      auto seedS = saber_test_utils::from_hex(seedS2);
      auto z = saber_test_utils::from_hex(z2);
      auto pkey = saber_test_utils::from_hex(pkey2);
      auto skey = saber_test_utils::from_hex(skey2);
      auto m = saber_test_utils::from_hex(m2);
      auto ctxt = saber_test_utils::from_hex(ctxt2);
      auto ss = saber_test_utils::from_hex(ss2);

      auto _seedA = std::span<const uint8_t, lightsaber_kem::seedBytes>(seedA);
      auto _seedS = std::span<const uint8_t, lightsaber_kem::noiseBytes>(seedS);
      auto _z = std::span<const uint8_t, lightsaber_kem::keyBytes>(z);
      auto _pkey = std::span<uint8_t, lightsaber_kem::PK_LEN>(pkey);
      auto _skey = std::span<uint8_t, lightsaber_kem::SK_LEN>(skey);
      auto _m = std::span<const uint8_t, lightsaber_kem::keyBytes>(m);
      auto _ctxt = std::span<uint8_t, lightsaber_kem::CT_LEN>(ctxt);
      auto _ss = std::span<uint8_t, sha3_256::DIGEST_LEN>(ss);

      std::vector<uint8_t> cpkey(_pkey.size(), 0);
      std::vector<uint8_t> cskey(_skey.size(), 0);
      std::vector<uint8_t> cctxt(_ctxt.size(), 0);
      std::vector<uint8_t> css0(_ss.size(), 0);
      std::vector<uint8_t> css1(_ss.size(), 0);

      auto _cpkey = std::span<uint8_t, lightsaber_kem::PK_LEN>(cpkey);
      auto _cskey = std::span<uint8_t, lightsaber_kem::SK_LEN>(cskey);
      auto _cctxt = std::span<uint8_t, lightsaber_kem::CT_LEN>(cctxt);
      auto _css0 = std::span<uint8_t, sha3_256::DIGEST_LEN>(css0);
      auto _css1 = std::span<uint8_t, sha3_256::DIGEST_LEN>(css1);

      lightsaber_kem::keygen(_seedA, _seedS, _z, _cpkey, _cskey);
      lightsaber_kem::encaps(_m, _cpkey, _cctxt, _css0);
      lightsaber_kem::decaps(_cctxt, _cskey, _css1);

      EXPECT_EQ(pkey, cpkey);
      EXPECT_EQ(skey, cskey);
      EXPECT_EQ(ctxt, cctxt);
      EXPECT_EQ(ss, css0);
      EXPECT_EQ(css0, css1);

      std::string empty_line;
      std::getline(file, empty_line);
    } else {
      break;
    }
  }

  file.close();
}

TEST(SaberKEM, LightSaberKeyEncapsulationMechanism)
{
  test_saber_kem<2, 13, 10, 3, 10, 32, 32, 32>();
}

TEST(SaberKEM, SaberKeyEncapsulationMechanism)
{
  test_saber_kem<3, 13, 10, 4, 8, 32, 32, 32>();
}

TEST(SaberKEM, FireSaberKeyEncapsulationMechanism)
{
  test_saber_kem<4, 13, 10, 6, 6, 32, 32, 32>();
}

TEST(SaberKEM, LightSaberKnownAnswerTests)
{
  kat_lightsaber();
}
